package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"io/fs"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	"gopkg.in/yaml.v3"
)

const (
	disclaimer             = "// Code generated by andrdru/gosvc/template\n// DO NOT EDIT\n"
	disclaimerExample      = "// Code generated by andrdru/gosvc/template\n// This is example, you may edit or remove it\n"
	disclaimerTemplateInfo = "# Code generated by andrdru/gosvc/template\n# DO NOT EDIT\n"
	tplPackageName         = "github.com/andrdru/gosvc/template"
	templateDataFile       = "template.yaml"
)

type (
	flags struct {
		pkgName *string
	}

	template struct {
		Package  string `yaml:"package"`
		Template struct {
			Version string `yaml:"version"`
		} `yaml:"template"`
	}
)

func main() {
	fmt.Println("Template init start")
	defer fmt.Println("Template init end")

	var fv = initFlags()
	if *fv.pkgName == "" {
		log.Fatal("Empty pkg name")
	}
	var pkgName = *fv.pkgName

	var templateInfo = template{
		Package: pkgName,
		Template: struct {
			Version string `yaml:"version"`
		}{
			Version: getCurrentTemplateVersion(),
		},
	}

	var err error
	var excludes = map[string]struct{}{
		".":             {},
		"init.go":       {},
		"template.yaml": {},
	}

	var templateDir, srcDir = getSrcDir()
	fmt.Printf("Template directory: %s\n", templateDir)
	fmt.Printf("Source directory:   %s\n", srcDir)

	var pkgDir = filepath.Join(srcDir, pkgName)
	fmt.Printf("New pkg directory:  %s\n", pkgDir)

	if _, err := os.Stat(pkgDir); !errors.Is(err, fs.ErrNotExist) {
		log.Fatal("New pkg directory already exists")
	}

	err = os.MkdirAll(pkgDir, 0700)
	if err != nil {
		log.Fatal("mkdir", pkgDir, err)
	}

	err = filepath.Walk(templateDir, func(path string, info fs.FileInfo, err error) error {
		if _, ok := excludes[info.Name()]; ok {
			return nil
		}

		var fileName = strings.TrimPrefix(path, templateDir)

		if info.IsDir() {
			var dir = filepath.Join(pkgDir, fileName)
			err = os.MkdirAll(dir, 0700)
			if err != nil {
				log.Fatal("mkdir", dir, err)
			}

			return nil
		}

		data, err := ioutil.ReadFile(path)
		if err != nil {
			log.Fatal("read file", err)
		}

		var filePath = filepath.Join(pkgDir, fileName)

		data = []byte(strings.ReplaceAll(string(data), tplPackageName, pkgName))

		if strings.HasSuffix(path, ".go") {
			var fileDisclaimer = disclaimer
			if strings.HasSuffix(path, ".example.go") {
				fileDisclaimer = disclaimerExample
			}

			data = append([]byte(fileDisclaimer), data...)
		}

		err = ioutil.WriteFile(filePath, data, fs.ModeAppend|fs.ModePerm)
		if err != nil {
			log.Fatal("write", err)
		}

		return nil
	})

	if err != nil {
		log.Fatal("error walk files: ", err)
	}

	data, err := yaml.Marshal(&templateInfo)
	if err != nil {
		log.Fatal("error marshal template info: ", err)
	}

	data = append([]byte(disclaimerTemplateInfo), data...)

	err = ioutil.WriteFile(filepath.Join(pkgDir, templateDataFile), data, fs.ModePerm)
	if err != nil {
		log.Fatal("write", err)
	}
}

func initFlags() (fv flags) {
	fv.pkgName = flag.String("pkg", "", "name of new package")

	flag.Parse()
	return fv
}

func getSrcDir() (string, string) {
	_, callerFile, _, _ := runtime.Caller(0)
	dir := filepath.Dir(callerFile)

	return dir, strings.TrimSuffix(dir, tplPackageName)
}

// getCurrentTemplateVersion
// :$ git describe --abbrev=0 --tags --match "template/*"
func getCurrentTemplateVersion() string {
	var (
		err    error
		buf    = bytes.Buffer{}
		buferr = bytes.Buffer{}
		cmd    = exec.Command("git", "describe", "--abbrev=0", "--tags", "--match", "template/*")
	)

	cmd.Stdout = &buf
	cmd.Stderr = &buferr

	err = cmd.Run()
	if err != nil {
		log.Fatal(err, buferr.String())
	}

	return strings.TrimPrefix(strings.Split(buf.String(), "\n")[0], "template/")
}
